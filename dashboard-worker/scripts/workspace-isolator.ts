#!/usr/bin/env bun

/**
 * üèóÔ∏è Fire22 Workspace Isolator
 * 
 * Creates isolated workspace environments with both linked and non-linked versions.
 * Each workspace gets its own complete environment with proper isolation while
 * maintaining the ability to link for development or run standalone for production.
 * 
 * Features:
 * - Individual workspace isolation
 * - Linked versions (development with workspace:* dependencies)
 * - Standalone versions (production with resolved dependencies)
 * - Independent package.json and configs for each workspace
 * - Separate build outputs and deployment targets
 * - Cross-workspace dependency management
 * 
 * @version 1.0.0
 * @author Fire22 Development Team
 */

import { writeFileSync, mkdirSync, existsSync, readFileSync, copyFileSync } from 'fs';
import { join, dirname } from 'path';
import { Logger, PerformanceTimer } from './shared-utilities.ts';

interface WorkspaceIsolationConfig {
  name: string;
  packageName: string;
  version: string;
  description: string;
  main: string;
  dependencies: Record<string, string>;
  devDependencies?: Record<string, string>;
  scripts: Record<string, string>;
  include: string[];
  exclude?: string[];
  cloudflare?: any;
  isolation: {
    standalone: boolean;
    linked: boolean;
    separateTests: boolean;
    independentDeploy: boolean;
  };
}

export class WorkspaceIsolator {
  private rootPath: string;
  private workspacesPath: string;
  private config: any;
  
  constructor(rootPath: string = process.cwd()) {
    this.rootPath = rootPath;
    this.workspacesPath = join(rootPath, 'workspaces');
    this.config = this.loadWorkspaceConfig();
  }
  
  /**
   * üöÄ Create all isolated workspaces
   */
  async createAllIsolatedWorkspaces(): Promise<void> {
    const timer = new PerformanceTimer('workspace-isolation');
    Logger.info('üèóÔ∏è  Fire22 Workspace Isolator v1.0.0');
    Logger.info('='.repeat(60));
    Logger.info('üî® Creating isolated workspace environments...');
    
    const workspaces = Object.entries(this.config.workspaces);
    Logger.info(`üì¶ Processing ${workspaces.length} workspaces`);
    
    for (const [workspaceKey, workspace] of workspaces) {
      const workspaceConfig = workspace as any;
      Logger.info(`\nüîß Isolating workspace: ${workspaceConfig.name}`);

      // Create workspace isolation config
      const isolationConfig = this.createIsolationConfig(workspaceKey, workspaceConfig);

      // Create isolated workspace environment
      await this.createIsolatedWorkspace(workspaceKey, isolationConfig);

      // Create linked version (development)
      await this.createLinkedVersion(workspaceKey, isolationConfig);

      // Create standalone version (production)
      await this.createStandaloneVersion(workspaceKey, isolationConfig);

      Logger.info(`‚úÖ ${workspaceConfig.name} isolation complete`);
    }

    // Create workspace orchestration files
    await this.createWorkspaceOrchestration();

    const performance = timer.finish();
    Logger.info(`\nüéâ Workspace isolation completed in ${performance.totalTime}ms`);
    this.logIsolationSummary();
  }  \n  /**\n   * üîß Create isolation configuration\n   */\n  private createIsolationConfig(workspaceKey: string, workspace: any): WorkspaceIsolationConfig {\n    return {\n      name: workspaceKey,\n      packageName: workspace.name,\n      version: workspace.version,\n      description: workspace.description,\n      main: workspace.main,\n      dependencies: workspace.dependencies || {},\n      devDependencies: {\n        '@types/bun': '^1.2.21',\n        'typescript': '^5.9.2'\n      },\n      scripts: {\n        'dev': 'bun run src/index.ts',\n        'build': 'bun build src/index.ts --outdir dist --target bun --format esm',\n        'build:standalone': 'bun build src/index.ts --outdir dist/standalone --target bun --format esm --minify',\n        'build:cloudflare': 'bun build src/index.ts --outdir dist/cloudflare --target bun --format esm --minify',\n        'test': 'bun test',\n        'test:watch': 'bun test --watch',\n        'lint': 'bunx eslint src/',\n        'typecheck': 'bunx tsc --noEmit',\n        'deploy:linked': 'wrangler deploy --config wrangler.linked.toml',\n        'deploy:standalone': 'wrangler deploy --config wrangler.standalone.toml'\n      },\n      include: workspace.include || [],\n      exclude: workspace.exclude || [],\n      cloudflare: workspace.cloudflare,\n      isolation: {\n        standalone: true,\n        linked: true,\n        separateTests: true,\n        independentDeploy: true\n      }\n    };\n  }\n  \n  /**\n   * üèóÔ∏è Create isolated workspace environment\n   */\n  private async createIsolatedWorkspace(workspaceKey: string, config: WorkspaceIsolationConfig): Promise<void> {\n    const workspacePath = join(this.workspacesPath, workspaceKey);\n    \n    // Ensure workspace directory structure\n    const dirs = [\n      'src', 'dist', 'dist/linked', 'dist/standalone', 'dist/cloudflare',\n      'tests', 'docs', '.wrangler', 'node_modules'\n    ];\n    \n    dirs.forEach(dir => {\n      const dirPath = join(workspacePath, dir);\n      if (!existsSync(dirPath)) {\n        mkdirSync(dirPath, { recursive: true });\n      }\n    });\n    \n    // Create base package.json\n    await this.createPackageJson(workspacePath, config);\n    \n    // Create TypeScript config\n    await this.createTypeScriptConfig(workspacePath, config);\n    \n    // Create workspace README\n    await this.createWorkspaceReadme(workspacePath, config);\n    \n    // Copy source files\n    await this.copySourceFiles(workspaceKey, config, workspacePath);\n    \n    Logger.debug(`Created isolated environment: ${config.packageName}`);\n  }\n  \n  /**\n   * üîó Create linked version (development)\n   */\n  private async createLinkedVersion(workspaceKey: string, config: WorkspaceIsolationConfig): Promise<void> {\n    const workspacePath = join(this.workspacesPath, workspaceKey);\n    \n    // Create linked package.json with workspace:* dependencies\n    const linkedPackageJson = {\n      name: config.packageName,\n      version: config.version,\n      description: `${config.description} (Linked Development Version)`,\n      type: 'module',\n      main: config.main,\n      scripts: {\n        ...config.scripts,\n        'build': 'bun build src/index.ts --outdir dist/linked --target bun --format esm --external @fire22/*',\n        'dev': 'bun run --watch src/index.ts'\n      },\n      dependencies: config.dependencies, // Keep workspace:* dependencies\n      devDependencies: config.devDependencies,\n      workspaces: {\n        linked: true,\n        development: true\n      },\n      fire22: {\n        workspace: workspaceKey,\n        isolation: 'linked',\n        buildTarget: 'development'\n      }\n    };\n    \n    writeFileSync(\n      join(workspacePath, 'package.linked.json'),\n      JSON.stringify(linkedPackageJson, null, 2)\n    );\n    \n    // Create linked Wrangler config\n    if (config.cloudflare) {\n      const linkedWranglerConfig = {\n        name: `${workspaceKey}-linked`,\n        compatibility_date: config.cloudflare.compatibility_date,\n        compatibility_flags: config.cloudflare.compatibility_flags,\n        main: 'dist/linked/index.js',\n        ...config.cloudflare,\n        vars: {\n          WORKSPACE_MODE: 'linked',\n          WORKSPACE_NAME: config.packageName,\n          BUILD_TARGET: 'development'\n        }\n      };\n      \n      writeFileSync(\n        join(workspacePath, 'wrangler.linked.toml'),\n        this.tomlStringify(linkedWranglerConfig)\n      );\n    }\n    \n    Logger.debug(`Created linked version: ${config.packageName}`);\n  }\n  \n  /**\n   * üì¶ Create standalone version (production)\n   */\n  private async createStandaloneVersion(workspaceKey: string, config: WorkspaceIsolationConfig): Promise<void> {\n    const workspacePath = join(this.workspacesPath, workspaceKey);\n    \n    // Resolve workspace:* dependencies to actual versions\n    const resolvedDependencies = this.resolveDependencies(config.dependencies);\n    \n    // Create standalone package.json with resolved dependencies\n    const standalonePackageJson = {\n      name: `${config.packageName}-standalone`,\n      version: config.version,\n      description: `${config.description} (Standalone Production Version)`,\n      type: 'module',\n      main: config.main,\n      scripts: {\n        ...config.scripts,\n        'build': 'bun build src/index.ts --outdir dist/standalone --target bun --format esm --minify --splitting',\n        'start': 'bun run dist/standalone/index.js'\n      },\n      dependencies: resolvedDependencies, // Resolved actual dependencies\n      devDependencies: config.devDependencies,\n      workspaces: {\n        linked: false,\n        standalone: true\n      },\n      fire22: {\n        workspace: workspaceKey,\n        isolation: 'standalone',\n        buildTarget: 'production'\n      }\n    };\n    \n    writeFileSync(\n      join(workspacePath, 'package.standalone.json'),\n      JSON.stringify(standalonePackageJson, null, 2)\n    );\n    \n    // Create standalone Wrangler config\n    if (config.cloudflare) {\n      const standaloneWranglerConfig = {\n        name: `${workspaceKey}-standalone`,\n        compatibility_date: config.cloudflare.compatibility_date,\n        compatibility_flags: config.cloudflare.compatibility_flags,\n        main: 'dist/standalone/index.js',\n        ...config.cloudflare,\n        vars: {\n          WORKSPACE_MODE: 'standalone',\n          WORKSPACE_NAME: config.packageName,\n          BUILD_TARGET: 'production'\n        }\n      };\n      \n      writeFileSync(\n        join(workspacePath, 'wrangler.standalone.toml'),\n        this.tomlStringify(standaloneWranglerConfig)\n      );\n    }\n    \n    Logger.debug(`Created standalone version: ${config.packageName}`);\n  }\n  \n  /**\n   * üìÑ Create package.json for workspace\n   */\n  private async createPackageJson(workspacePath: string, config: WorkspaceIsolationConfig): Promise<void> {\n    const packageJson = {\n      name: config.packageName,\n      version: config.version,\n      description: config.description,\n      type: 'module',\n      main: config.main,\n      scripts: config.scripts,\n      dependencies: config.dependencies,\n      devDependencies: config.devDependencies,\n      fire22: {\n        workspace: config.name,\n        isolation: {\n          standalone: config.isolation.standalone,\n          linked: config.isolation.linked,\n          separateTests: config.isolation.separateTests,\n          independentDeploy: config.isolation.independentDeploy\n        },\n        include: config.include,\n        exclude: config.exclude\n      }\n    };\n    \n    writeFileSync(\n      join(workspacePath, 'package.json'),\n      JSON.stringify(packageJson, null, 2)\n    );\n  }\n  \n  /**\n   * üìù Create TypeScript configuration\n   */\n  private async createTypeScriptConfig(workspacePath: string, config: WorkspaceIsolationConfig): Promise<void> {\n    const tsConfig = {\n      compilerOptions: {\n        target: 'ES2022',\n        module: 'ESNext',\n        moduleResolution: 'bundler',\n        allowImportingTsExtensions: true,\n        noEmit: true,\n        strict: true,\n        skipLibCheck: true,\n        forceConsistentCasingInFileNames: true,\n        types: ['bun-types']\n      },\n      include: ['src/**/*', 'tests/**/*'],\n      exclude: ['node_modules', 'dist']\n    };\n    \n    writeFileSync(\n      join(workspacePath, 'tsconfig.json'),\n      JSON.stringify(tsConfig, null, 2)\n    );\n  }\n  \n  /**\n   * üìö Create workspace README\n   */\n  private async createWorkspaceReadme(workspacePath: string, config: WorkspaceIsolationConfig): Promise<void> {\n    const readme = `# ${config.packageName}\n\n${config.description}\n\n## Workspace Isolation\n\nThis workspace exists in both **linked** and **standalone** modes:\n\n### üîó Linked Mode (Development)\n- Uses \\`workspace:*\\` dependencies\n- Hot reloading and fast development\n- Cross-workspace dependency resolution\n- Run: \\`bun run dev\\`\n- Deploy: \\`bun run deploy:linked\\`\n\n### üì¶ Standalone Mode (Production)\n- Resolved dependencies (no workspace references)\n- Optimized and minified builds\n- Independent deployment\n- Run: \\`bun run build && bun run start\\`\n- Deploy: \\`bun run deploy:standalone\\`\n\n## Scripts\n\n\\`\\`\\`bash\n# Development (Linked)\nbun run dev                 # Start development server\nbun run build               # Build linked version\nbun run deploy:linked       # Deploy linked version\n\n# Production (Standalone)\nbun run build:standalone    # Build standalone version\nbun run deploy:standalone   # Deploy standalone version\n\n# Testing\nbun test                    # Run tests\nbun run typecheck          # TypeScript checking\nbun run lint               # Lint code\n\\`\\`\\`\n\n## Dependencies\n\n${Object.entries(config.dependencies).map(([dep, ver]) => `- \\`${dep}\\`: ${ver}`).join('\\n')}\n\n## Architecture\n\n- **Isolation**: Each workspace is completely independent\n- **Linking**: Development mode uses workspace references\n- **Deployment**: Production uses resolved dependencies\n- **Testing**: Isolated test environment\n- **Building**: Separate build outputs for each mode\n`;\n    \n    writeFileSync(join(workspacePath, 'README.md'), readme);\n  }\n  \n  /**\n   * üìÅ Copy source files to workspace\n   */\n  private async copySourceFiles(workspaceKey: string, config: WorkspaceIsolationConfig, workspacePath: string): Promise<void> {\n    const srcPath = join(workspacePath, 'src');\n    \n    // Create index.ts based on workspace main file\n    let mainContent = '';\n    const mainFile = join(this.rootPath, config.main);\n    \n    if (existsSync(mainFile)) {\n      mainContent = readFileSync(mainFile, 'utf-8');\n    } else {\n      // Create default index.ts\n      mainContent = `/**\n * ${config.packageName}\n * ${config.description}\n * \n * Workspace: ${workspaceKey}\n * Isolation: Both linked and standalone modes supported\n */\n\nexport default {\n  name: '${config.packageName}',\n  version: '${config.version}',\n  workspace: '${workspaceKey}',\n  mode: process.env.WORKSPACE_MODE || 'development'\n};\n\nconsole.log('üöÄ ${config.packageName} initialized');\n`;\n    }\n    \n    writeFileSync(join(srcPath, 'index.ts'), mainContent);\n    \n    // Copy included files\n    config.include.forEach(pattern => {\n      const sourcePath = join(this.rootPath, pattern);\n      if (existsSync(sourcePath)) {\n        const destPath = join(srcPath, pattern.split('/').pop() || 'file.ts');\n        try {\n          copyFileSync(sourcePath, destPath);\n          Logger.debug(`Copied: ${pattern} ‚Üí ${destPath}`);\n        } catch (error) {\n          Logger.warn(`Failed to copy ${pattern}:`, error);\n        }\n      }\n    });\n  }\n  \n  /**\n   * üéõÔ∏è Create workspace orchestration files\n   */\n  private async createWorkspaceOrchestration(): Promise<void> {\n    const orchestrationPath = join(this.workspacesPath, 'orchestration.json');\n    const workspaceList = Object.keys(this.config.workspaces);\n    \n    const orchestration = {\n      version: '1.0.0',\n      created: new Date().toISOString(),\n      workspaces: workspaceList.length,\n      isolation: {\n        type: 'complete',\n        modes: ['linked', 'standalone'],\n        deployments: ['development', 'production']\n      },\n      workspaceList,\n      buildOrder: this.calculateBuildOrder(),\n      scripts: {\n        'build:all:linked': workspaceList.map(w => `cd ${w} && bun run build`).join(' && '),\n        'build:all:standalone': workspaceList.map(w => `cd ${w} && bun run build:standalone`).join(' && '),\n        'test:all': workspaceList.map(w => `cd ${w} && bun test`).join(' && '),\n        'deploy:all:linked': workspaceList.map(w => `cd ${w} && bun run deploy:linked`).join(' && '),\n        'deploy:all:standalone': workspaceList.map(w => `cd ${w} && bun run deploy:standalone`).join(' && ')\n      }\n    };\n    \n    writeFileSync(orchestrationPath, JSON.stringify(orchestration, null, 2));\n    \n    // Create orchestration script\n    const orchestrationScript = `#!/usr/bin/env bun\n\n/**\n * üéº Fire22 Workspace Orchestration\n * Manage all isolated workspaces\n */\n\nconst args = process.argv.slice(2);\nconst command = args[0] || 'help';\n\nconst workspaces = ${JSON.stringify(workspaceList)};\n\nswitch (command) {\n  case 'build:linked':\n    console.log('üîó Building all linked workspaces...');\n    for (const ws of workspaces) {\n      await Bun.$\\`cd \\${ws} && bun run build\\`;\n    }\n    break;\n    \n  case 'build:standalone':\n    console.log('üì¶ Building all standalone workspaces...');\n    for (const ws of workspaces) {\n      await Bun.$\\`cd \\${ws} && bun run build:standalone\\`;\n    }\n    break;\n    \n  case 'test:all':\n    console.log('üß™ Testing all workspaces...');\n    for (const ws of workspaces) {\n      await Bun.$\\`cd \\${ws} && bun test\\`;\n    }\n    break;\n    \n  default:\n    console.log('Usage: bun orchestration.ts [build:linked|build:standalone|test:all]');\n}\n`;\n    \n    writeFileSync(join(this.workspacesPath, 'orchestration.ts'), orchestrationScript);\n  }\n  \n  /**\n   * üîÑ Resolve workspace:* dependencies to actual versions\n   */\n  private resolveDependencies(dependencies: Record<string, string>): Record<string, string> {\n    const resolved: Record<string, string> = {};\n    \n    Object.entries(dependencies).forEach(([dep, version]) => {\n      if (version === 'workspace:*') {\n        // Find the actual workspace version\n        const workspaceName = dep.replace('@fire22/', '');\n        const workspace = Object.values(this.config.workspaces).find(\n          (ws: any) => ws.name === dep\n        ) as any;\n        \n        if (workspace) {\n          resolved[dep] = workspace.version;\n        } else {\n          // Default to main workspace version\n          resolved[dep] = this.config.version;\n        }\n      } else {\n        resolved[dep] = version;\n      }\n    });\n    \n    return resolved;\n  }\n  \n  /**\n   * üìê Calculate build order\n   */\n  private calculateBuildOrder(): string[] {\n    // Use the orchestration build order from config\n    return this.config.orchestration?.buildOrder || Object.keys(this.config.workspaces);\n  }\n  \n  /**\n   * üìä Log isolation summary\n   */\n  private logIsolationSummary(): void {\n    const workspaceCount = Object.keys(this.config.workspaces).length;\n    \n    Logger.info('\n' + '='.repeat(60));\n    Logger.info('üéâ WORKSPACE ISOLATION SUMMARY');\n    Logger.info('='.repeat(60));\n    \n    Logger.info(`üì¶ Workspaces Created: ${workspaceCount}`);\n    Logger.info(`üîó Linked Versions: ${workspaceCount} (development)`);\n    Logger.info(`üì¶ Standalone Versions: ${workspaceCount} (production)`);\n    Logger.info(`üèóÔ∏è  Total Environments: ${workspaceCount * 2}`);\n    \n    Logger.info('\\nüìã Workspace Structure:');\n    Object.entries(this.config.workspaces).forEach(([key, workspace]: [string, any]) => {\n      Logger.info(`  üìÅ ${key}/`);\n      Logger.info(`    ‚îî‚îÄ‚îÄ ${workspace.name}`);\n      Logger.info(`        ‚îú‚îÄ‚îÄ üîó Linked (dev): package.linked.json`);\n      Logger.info(`        ‚îú‚îÄ‚îÄ üì¶ Standalone (prod): package.standalone.json`);\n      Logger.info(`        ‚îú‚îÄ‚îÄ ‚òÅÔ∏è  Cloudflare configs: wrangler.{linked|standalone}.toml`);\n      Logger.info(`        ‚îî‚îÄ‚îÄ üéØ Independent deployment ready`);\n    });\n    \n    Logger.info('\\nüí° Next Steps:');\n    Logger.info('  1. Navigate to any workspace: cd workspaces/pattern-system');\n    Logger.info('  2. Development mode: bun run dev (uses linked dependencies)');\n    Logger.info('  3. Production build: bun run build:standalone');\n    Logger.info('  4. Deploy linked: bun run deploy:linked');\n    Logger.info('  5. Deploy standalone: bun run deploy:standalone');\n    Logger.info('  6. Orchestrate all: bun workspaces/orchestration.ts build:all');\n    \n    Logger.info('='.repeat(60));\n  }\n  \n  // === UTILITY METHODS ===\n  \n  private loadWorkspaceConfig(): any {\n    const configPath = join(this.rootPath, 'workspace-config.json');\n    if (!existsSync(configPath)) {\n      throw new Error('workspace-config.json not found');\n    }\n    return JSON.parse(readFileSync(configPath, 'utf-8'));\n  }\n  \n  private tomlStringify(obj: any): string {\n    // Simple TOML stringifier - in production, use a proper TOML library\n    let result = '';\n    \n    Object.entries(obj).forEach(([key, value]) => {\n      if (typeof value === 'object' && !Array.isArray(value)) {\n        result += `[${key}]\\n`;\n        Object.entries(value).forEach(([subKey, subValue]) => {\n          result += `${subKey} = ${JSON.stringify(subValue)}\\n`;\n        });\n        result += '\\n';\n      } else {\n        result += `${key} = ${JSON.stringify(value)}\\n`;\n      }\n    });\n    \n    return result;\n  }\n}\n\n// === CLI INTERFACE ===\n\nif (import.meta.main) {\n  const args = process.argv.slice(2);\n  const command = args[0] || 'isolate';\n  \n  const isolator = new WorkspaceIsolator();\n  \n  try {\n    switch (command) {\n      case 'isolate':\n      case 'create':\n        await isolator.createAllIsolatedWorkspaces();\n        break;\n        \n      default:\n        console.log('Usage: bun workspace-isolator.ts [isolate|create]');\n        console.log('  isolate - Create isolated workspace environments');\n        console.log('  create  - Alias for isolate');\n        process.exit(1);\n    }\n  } catch (error) {\n    Logger.error('‚ùå Workspace isolation failed:', error);\n    process.exit(1);\n  }\n}\n\nexport default WorkspaceIsolator;