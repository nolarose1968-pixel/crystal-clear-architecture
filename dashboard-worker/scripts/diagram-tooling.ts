#!/usr/bin/env bun

/**
 * ğŸ”§ Fire22 Diagram Tooling System
 *
 * Uses mermaid.js for initial diagram structure and logic,
 * then translates to stunning ANSI-colored ASCII art for Node.js console display.
 *
 * Supports: chalk, kleur, ansi-colors for terminal visualization
 */

import { spawn } from 'child_process';
import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join, dirname } from 'path';

// ANSI Color Libraries
import chalk from 'chalk';
import kleur from 'kleur';
import ansiColors from 'ansi-colors';

interface DiagramConfig {
  type: 'flowchart' | 'sequence' | 'class' | 'state' | 'gantt' | 'pie';
  title: string;
  description: string;
  mermaidCode: string;
  outputFormat: 'ansi' | 'html' | 'svg' | 'png';
  colorScheme: 'fire22' | 'professional' | 'vibrant' | 'monochrome';
  width: number;
  height: number;
}

interface AnsiArtConfig {
  useUnicode: boolean;
  colorPalette: 'fire22' | 'professional' | 'vibrant' | 'monochrome';
  animation: boolean;
  interactive: boolean;
}

class Fire22DiagramTooling {
  private config: DiagramConfig;
  private ansiConfig: AnsiArtConfig;
  private colorLibrary: 'chalk' | 'kleur' | 'ansi-colors';

  constructor(
    config: DiagramConfig,
    ansiConfig: AnsiArtConfig = {
      useUnicode: true,
      colorPalette: 'fire22',
      animation: false,
      interactive: false,
    },
    colorLibrary: 'chalk' | 'kleur' | 'ansi-colors' = 'chalk'
  ) {
    this.config = config;
    this.ansiConfig = ansiConfig;
    this.colorLibrary = colorLibrary;
  }

  /**
   * ğŸ¨ Generate Mermaid Diagram
   */
  async generateMermaidDiagram(): Promise<string> {
    console.log(chalk.blue('ğŸ”§ Generating Mermaid diagram...'));

    const mermaidTemplate = this.createMermaidTemplate();
    const tempFile = join(process.cwd(), 'temp-diagram.mmd');

    try {
      writeFileSync(tempFile, mermaidTemplate, 'utf8');
      console.log(chalk.green('âœ… Mermaid diagram generated successfully'));
      return mermaidTemplate;
    } catch (error) {
      console.error(chalk.red('âŒ Error generating Mermaid diagram:'), error);
      throw error;
    }
  }

  /**
   * ğŸ­ Translate to ANSI ASCII Art
   */
  translateToAnsiArt(mermaidOutput: string): string {
    console.log(chalk.blue('ğŸ­ Translating to ANSI ASCII art...'));

    const asciiArt = this.convertMermaidToAscii(mermaidOutput);
    const coloredAscii = this.applyAnsiColors(asciiArt);

    console.log(chalk.green('âœ… ANSI ASCII art generated successfully'));
    return coloredAscii;
  }

  /**
   * ğŸ“Š Display in Console
   */
  displayInConsole(asciiArt: string): void {
    console.clear();
    console.log(chalk.yellow('ğŸ”¥ Fire22 Diagram Tooling System'));
    console.log(chalk.gray('='.repeat(50)));
    console.log();
    console.log(asciiArt);
    console.log();
    console.log(chalk.gray('='.repeat(50)));
    console.log(chalk.blue(`ğŸ“Š Diagram: ${this.config.title}`));
    console.log(chalk.gray(`Type: ${this.config.type} | Format: ${this.config.outputFormat}`));
  }

  /**
   * ğŸ¨ Create Mermaid Template
   */
  private createMermaidTemplate(): string {
    const { type, title, mermaidCode } = this.config;

    return `%% Fire22 ${title}
%% Generated by Fire22 Diagram Tooling System
%% Type: ${type}
%% Timestamp: ${new Date().toISOString()}

${mermaidCode}`;
  }

  /**
   * ğŸ”„ Convert Mermaid to ASCII
   */
  private convertMermaidToAscii(mermaidCode: string): string {
    // Parse Mermaid syntax and convert to ASCII representation
    const lines = mermaidCode.split('\n');
    const asciiLines: string[] = [];

    for (const line of lines) {
      if (line.trim().startsWith('%%')) continue; // Skip comments

      const asciiLine = this.parseMermaidLine(line);
      if (asciiLine) asciiLines.push(asciiLine);
    }

    return asciiLines.join('\n');
  }

  /**
   * ğŸ“ Parse Individual Mermaid Line
   */
  private parseMermaidLine(line: string): string {
    const trimmed = line.trim();

    // Flowchart parsing
    if (trimmed.includes('-->')) {
      return this.parseFlowchartLine(trimmed);
    }

    // Sequence diagram parsing
    if (trimmed.includes('->>')) {
      return this.parseSequenceLine(trimmed);
    }

    // Class diagram parsing
    if (trimmed.includes('class')) {
      return this.parseClassLine(trimmed);
    }

    // State diagram parsing
    if (trimmed.includes('state')) {
      return this.parseStateLine(trimmed);
    }

    return trimmed;
  }

  /**
   * ğŸ”€ Parse Flowchart Lines
   */
  private parseFlowchartLine(line: string): string {
    const parts = line.split('-->');
    const from = parts[0].trim();
    const to = parts[1].trim();

    return `  ${from} â”€â”€â†’ ${to}`;
  }

  /**
   * ğŸ“¡ Parse Sequence Lines
   */
  private parseSequenceLine(line: string): string {
    const parts = line.split('->>');
    const from = parts[0].trim();
    const to = parts[1].trim();

    return `  ${from} â”€â”€â–¶ ${to}`;
  }

  /**
   * ğŸ—ï¸ Parse Class Lines
   */
  private parseClassLine(line: string): string {
    if (line.includes('class')) {
      const className = line.replace('class', '').trim();
      return `  â”Œâ”€ ${className} â”€â”`;
    }
    return line;
  }

  /**
   * ğŸ¯ Parse State Lines
   */
  private parseStateLine(line: string): string {
    if (line.includes('state')) {
      const stateName = line.replace('state', '').trim();
      return `  [${stateName}]`;
    }
    return line;
  }

  /**
   * ğŸŒˆ Apply ANSI Colors
   */
  private applyAnsiColors(asciiArt: string): string {
    const lines = asciiArt.split('\n');
    const coloredLines: string[] = [];

    for (const line of lines) {
      const coloredLine = this.colorizeLine(line);
      coloredLines.push(coloredLine);
    }

    return coloredLines.join('\n');
  }

  /**
   * ğŸ¨ Colorize Individual Line
   */
  private colorizeLine(line: string): string {
    const { colorPalette } = this.ansiConfig;

    switch (colorPalette) {
      case 'fire22':
        return this.applyFire22Colors(line);
      case 'professional':
        return this.applyProfessionalColors(line);
      case 'vibrant':
        return this.applyVibrantColors(line);
      case 'monochrome':
        return this.applyMonochromeColors(line);
      default:
        return this.applyFire22Colors(line);
    }
  }

  /**
   * ğŸ”¥ Apply Fire22 Color Scheme
   */
  private applyFire22Colors(line: string): string {
    if (line.includes('â”€â”€â†’')) {
      return chalk.hex('#fdbb2d')(line.replace('â”€â”€â†’', 'â”€â”€â†’'));
    }
    if (line.includes('â”€â”€â–¶')) {
      return chalk.hex('#b21f1f')(line.replace('â”€â”€â–¶', 'â”€â”€â–¶'));
    }
    if (line.includes('â”Œâ”€') || line.includes('â”€â”')) {
      return chalk.hex('#fdbb2d')(line);
    }
    if (line.includes('[') && line.includes(']')) {
      return chalk.hex('#b21f1f')(line);
    }
    if (line.includes('ğŸ“Š') || line.includes('ğŸ”§')) {
      return chalk.blue(line);
    }
    if (line.includes('âœ…') || line.includes('ğŸ¯')) {
      return chalk.green(line);
    }
    if (line.includes('âŒ') || line.includes('âš ï¸')) {
      return chalk.red(line);
    }

    return chalk.white(line);
  }

  /**
   * ğŸ’¼ Apply Professional Color Scheme
   */
  private applyProfessionalColors(line: string): string {
    if (line.includes('â”€â”€â†’') || line.includes('â”€â”€â–¶')) {
      return chalk.blue(line);
    }
    if (line.includes('â”Œâ”€') || line.includes('â”€â”')) {
      return chalk.cyan(line);
    }
    if (line.includes('[') && line.includes(']')) {
      return chalk.magenta(line);
    }
    return chalk.white(line);
  }

  /**
   * ğŸŒˆ Apply Vibrant Color Scheme
   */
  private applyVibrantColors(line: string): string {
    if (line.includes('â”€â”€â†’')) {
      return chalk.green(line);
    }
    if (line.includes('â”€â”€â–¶')) {
      return chalk.red(line);
    }
    if (line.includes('â”Œâ”€') || line.includes('â”€â”')) {
      return chalk.yellow(line);
    }
    if (line.includes('[') && line.includes(']')) {
      return chalk.magenta(line);
    }
    return chalk.white(line);
  }

  /**
   * âš« Apply Monochrome Color Scheme
   */
  private applyMonochromeColors(line: string): string {
    return chalk.gray(line);
  }

  /**
   * ğŸš€ Run Complete Workflow
   */
  async run(): Promise<void> {
    try {
      console.log(chalk.blue('ğŸš€ Starting Fire22 Diagram Tooling System...'));

      // Generate Mermaid diagram
      const mermaidOutput = await this.generateMermaidDiagram();

      // Translate to ANSI ASCII art
      const asciiArt = this.translateToAnsiArt(mermaidOutput);

      // Display in console
      this.displayInConsole(asciiArt);

      console.log(chalk.green('ğŸ‰ Diagram tooling workflow completed successfully!'));
    } catch (error) {
      console.error(chalk.red('ğŸ’¥ Error in diagram tooling workflow:'), error);
      process.exit(1);
    }
  }
}

// Export for use in other modules
export { Fire22DiagramTooling, DiagramConfig, AnsiArtConfig };

// CLI Interface
if (import.meta.main) {
  const config: DiagramConfig = {
    type: 'flowchart',
    title: 'Fire22 Version Management System',
    description: 'Comprehensive version control and build automation',
    mermaidCode: `
      graph TD
        A[Version Manager] --> B[Patch Version]
        A --> C[Minor Version]
        A --> D[Major Version]
        A --> E[Prerelease]
        
        B --> F[3.0.6 â†’ 3.0.7]
        C --> G[3.0.6 â†’ 3.1.0]
        D --> H[3.0.6 â†’ 4.0.0]
        E --> I[3.0.6 â†’ 3.0.7-beta.0]
        
        F --> J[Build Process]
        G --> J
        H --> J
        I --> J
        
        J --> K[Package Build]
        J --> L[Documentation]
        J --> M[Testing]
        
        K --> N[Deploy]
        L --> N
        M --> N
    `,
    outputFormat: 'ansi',
    colorScheme: 'fire22',
    width: 80,
    height: 24,
  };

  const ansiConfig: AnsiArtConfig = {
    useUnicode: true,
    colorPalette: 'fire22',
    animation: false,
    interactive: false,
  };

  const tooling = new Fire22DiagramTooling(config, ansiConfig, 'chalk');
  await tooling.run();
}
