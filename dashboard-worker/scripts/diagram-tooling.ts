#!/usr/bin/env bun

/**
 * 🔧 Fire22 Diagram Tooling System
 * 
 * Uses mermaid.js for initial diagram structure and logic,
 * then translates to stunning ANSI-colored ASCII art for Node.js console display.
 * 
 * Supports: chalk, kleur, ansi-colors for terminal visualization
 */

import { spawn } from 'child_process';
import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join, dirname } from 'path';

// ANSI Color Libraries
import chalk from 'chalk';
import kleur from 'kleur';
import ansiColors from 'ansi-colors';

interface DiagramConfig {
  type: 'flowchart' | 'sequence' | 'class' | 'state' | 'gantt' | 'pie';
  title: string;
  description: string;
  mermaidCode: string;
  outputFormat: 'ansi' | 'html' | 'svg' | 'png';
  colorScheme: 'fire22' | 'professional' | 'vibrant' | 'monochrome';
  width: number;
  height: number;
}

interface AnsiArtConfig {
  useUnicode: boolean;
  colorPalette: 'fire22' | 'professional' | 'vibrant' | 'monochrome';
  animation: boolean;
  interactive: boolean;
}

class Fire22DiagramTooling {
  private config: DiagramConfig;
  private ansiConfig: AnsiArtConfig;
  private colorLibrary: 'chalk' | 'kleur' | 'ansi-colors';

  constructor(
    config: DiagramConfig,
    ansiConfig: AnsiArtConfig = {
      useUnicode: true,
      colorPalette: 'fire22',
      animation: false,
      interactive: false
    },
    colorLibrary: 'chalk' | 'kleur' | 'ansi-colors' = 'chalk'
  ) {
    this.config = config;
    this.ansiConfig = ansiConfig;
    this.colorLibrary = colorLibrary;
  }

  /**
   * 🎨 Generate Mermaid Diagram
   */
  async generateMermaidDiagram(): Promise<string> {
    console.log(chalk.blue('🔧 Generating Mermaid diagram...'));
    
    const mermaidTemplate = this.createMermaidTemplate();
    const tempFile = join(process.cwd(), 'temp-diagram.mmd');
    
    try {
      writeFileSync(tempFile, mermaidTemplate, 'utf8');
      console.log(chalk.green('✅ Mermaid diagram generated successfully'));
      return mermaidTemplate;
    } catch (error) {
      console.error(chalk.red('❌ Error generating Mermaid diagram:'), error);
      throw error;
    }
  }

  /**
   * 🎭 Translate to ANSI ASCII Art
   */
  translateToAnsiArt(mermaidOutput: string): string {
    console.log(chalk.blue('🎭 Translating to ANSI ASCII art...'));
    
    const asciiArt = this.convertMermaidToAscii(mermaidOutput);
    const coloredAscii = this.applyAnsiColors(asciiArt);
    
    console.log(chalk.green('✅ ANSI ASCII art generated successfully'));
    return coloredAscii;
  }

  /**
   * 📊 Display in Console
   */
  displayInConsole(asciiArt: string): void {
    console.clear();
    console.log(chalk.yellow('🔥 Fire22 Diagram Tooling System'));
    console.log(chalk.gray('='.repeat(50)));
    console.log();
    console.log(asciiArt);
    console.log();
    console.log(chalk.gray('='.repeat(50)));
    console.log(chalk.blue(`📊 Diagram: ${this.config.title}`));
    console.log(chalk.gray(`Type: ${this.config.type} | Format: ${this.config.outputFormat}`));
  }

  /**
   * 🎨 Create Mermaid Template
   */
  private createMermaidTemplate(): string {
    const { type, title, mermaidCode } = this.config;
    
    return `%% Fire22 ${title}
%% Generated by Fire22 Diagram Tooling System
%% Type: ${type}
%% Timestamp: ${new Date().toISOString()}

${mermaidCode}`;
  }

  /**
   * 🔄 Convert Mermaid to ASCII
   */
  private convertMermaidToAscii(mermaidCode: string): string {
    // Parse Mermaid syntax and convert to ASCII representation
    const lines = mermaidCode.split('\n');
    const asciiLines: string[] = [];
    
    for (const line of lines) {
      if (line.trim().startsWith('%%')) continue; // Skip comments
      
      const asciiLine = this.parseMermaidLine(line);
      if (asciiLine) asciiLines.push(asciiLine);
    }
    
    return asciiLines.join('\n');
  }

  /**
   * 📝 Parse Individual Mermaid Line
   */
  private parseMermaidLine(line: string): string {
    const trimmed = line.trim();
    
    // Flowchart parsing
    if (trimmed.includes('-->')) {
      return this.parseFlowchartLine(trimmed);
    }
    
    // Sequence diagram parsing
    if (trimmed.includes('->>')) {
      return this.parseSequenceLine(trimmed);
    }
    
    // Class diagram parsing
    if (trimmed.includes('class')) {
      return this.parseClassLine(trimmed);
    }
    
    // State diagram parsing
    if (trimmed.includes('state')) {
      return this.parseStateLine(trimmed);
    }
    
    return trimmed;
  }

  /**
   * 🔀 Parse Flowchart Lines
   */
  private parseFlowchartLine(line: string): string {
    const parts = line.split('-->');
    const from = parts[0].trim();
    const to = parts[1].trim();
    
    return `  ${from} ──→ ${to}`;
  }

  /**
   * 📡 Parse Sequence Lines
   */
  private parseSequenceLine(line: string): string {
    const parts = line.split('->>');
    const from = parts[0].trim();
    const to = parts[1].trim();
    
    return `  ${from} ──▶ ${to}`;
  }

  /**
   * 🏗️ Parse Class Lines
   */
  private parseClassLine(line: string): string {
    if (line.includes('class')) {
      const className = line.replace('class', '').trim();
      return `  ┌─ ${className} ─┐`;
    }
    return line;
  }

  /**
   * 🎯 Parse State Lines
   */
  private parseStateLine(line: string): string {
    if (line.includes('state')) {
      const stateName = line.replace('state', '').trim();
      return `  [${stateName}]`;
    }
    return line;
  }

  /**
   * 🌈 Apply ANSI Colors
   */
  private applyAnsiColors(asciiArt: string): string {
    const lines = asciiArt.split('\n');
    const coloredLines: string[] = [];
    
    for (const line of lines) {
      const coloredLine = this.colorizeLine(line);
      coloredLines.push(coloredLine);
    }
    
    return coloredLines.join('\n');
  }

  /**
   * 🎨 Colorize Individual Line
   */
  private colorizeLine(line: string): string {
    const { colorPalette } = this.ansiConfig;
    
    switch (colorPalette) {
      case 'fire22':
        return this.applyFire22Colors(line);
      case 'professional':
        return this.applyProfessionalColors(line);
      case 'vibrant':
        return this.applyVibrantColors(line);
      case 'monochrome':
        return this.applyMonochromeColors(line);
      default:
        return this.applyFire22Colors(line);
    }
  }

  /**
   * 🔥 Apply Fire22 Color Scheme
   */
  private applyFire22Colors(line: string): string {
    if (line.includes('──→')) {
      return chalk.hex('#fdbb2d')(line.replace('──→', '──→'));
    }
    if (line.includes('──▶')) {
      return chalk.hex('#b21f1f')(line.replace('──▶', '──▶'));
    }
    if (line.includes('┌─') || line.includes('─┐')) {
      return chalk.hex('#fdbb2d')(line);
    }
    if (line.includes('[') && line.includes(']')) {
      return chalk.hex('#b21f1f')(line);
    }
    if (line.includes('📊') || line.includes('🔧')) {
      return chalk.blue(line);
    }
    if (line.includes('✅') || line.includes('🎯')) {
      return chalk.green(line);
    }
    if (line.includes('❌') || line.includes('⚠️')) {
      return chalk.red(line);
    }
    
    return chalk.white(line);
  }

  /**
   * 💼 Apply Professional Color Scheme
   */
  private applyProfessionalColors(line: string): string {
    if (line.includes('──→') || line.includes('──▶')) {
      return chalk.blue(line);
    }
    if (line.includes('┌─') || line.includes('─┐')) {
      return chalk.cyan(line);
    }
    if (line.includes('[') && line.includes(']')) {
      return chalk.magenta(line);
    }
    return chalk.white(line);
  }

  /**
   * 🌈 Apply Vibrant Color Scheme
   */
  private applyVibrantColors(line: string): string {
    if (line.includes('──→')) {
      return chalk.green(line);
    }
    if (line.includes('──▶')) {
      return chalk.red(line);
    }
    if (line.includes('┌─') || line.includes('─┐')) {
      return chalk.yellow(line);
    }
    if (line.includes('[') && line.includes(']')) {
      return chalk.magenta(line);
    }
    return chalk.white(line);
  }

  /**
   * ⚫ Apply Monochrome Color Scheme
   */
  private applyMonochromeColors(line: string): string {
    return chalk.gray(line);
  }

  /**
   * 🚀 Run Complete Workflow
   */
  async run(): Promise<void> {
    try {
      console.log(chalk.blue('🚀 Starting Fire22 Diagram Tooling System...'));
      
      // Generate Mermaid diagram
      const mermaidOutput = await this.generateMermaidDiagram();
      
      // Translate to ANSI ASCII art
      const asciiArt = this.translateToAnsiArt(mermaidOutput);
      
      // Display in console
      this.displayInConsole(asciiArt);
      
      console.log(chalk.green('🎉 Diagram tooling workflow completed successfully!'));
      
    } catch (error) {
      console.error(chalk.red('💥 Error in diagram tooling workflow:'), error);
      process.exit(1);
    }
  }
}

// Export for use in other modules
export { Fire22DiagramTooling, DiagramConfig, AnsiArtConfig };

// CLI Interface
if (import.meta.main) {
  const config: DiagramConfig = {
    type: 'flowchart',
    title: 'Fire22 Version Management System',
    description: 'Comprehensive version control and build automation',
    mermaidCode: `
      graph TD
        A[Version Manager] --> B[Patch Version]
        A --> C[Minor Version]
        A --> D[Major Version]
        A --> E[Prerelease]
        
        B --> F[3.0.6 → 3.0.7]
        C --> G[3.0.6 → 3.1.0]
        D --> H[3.0.6 → 4.0.0]
        E --> I[3.0.6 → 3.0.7-beta.0]
        
        F --> J[Build Process]
        G --> J
        H --> J
        I --> J
        
        J --> K[Package Build]
        J --> L[Documentation]
        J --> M[Testing]
        
        K --> N[Deploy]
        L --> N
        M --> N
    `,
    outputFormat: 'ansi',
    colorScheme: 'fire22',
    width: 80,
    height: 24
  };

  const ansiConfig: AnsiArtConfig = {
    useUnicode: true,
    colorPalette: 'fire22',
    animation: false,
    interactive: false
  };

  const tooling = new Fire22DiagramTooling(config, ansiConfig, 'chalk');
  await tooling.run();
}
