/**
 * Domain Worker Factory
 * Crystal Clear Architecture Cloudflare Integration
 *
 * Creates and manages domain-specific Cloudflare Workers with unified
 * deployment, monitoring, and communication patterns
 */

import type { WorkerEntrypoint } from 'cloudflare:workers';

interface DomainConfig {
  name: string;
  database: string;
  cacheNamespace: string;
  routes: string[];
  dependencies: string[];
  environment: Record<string, string>;
}

interface WorkerDeployment {
  name: string;
  script: string;
  routes: string[];
  environment: Record<string, string>;
}

export class DomainWorkerFactory {
  private static instance: DomainWorkerFactory;
  private domainConfigs: Map<string, DomainConfig> = new Map();

  private constructor() {
    this.initializeDomainConfigs();
  }

  static getInstance(): DomainWorkerFactory {
    if (!DomainWorkerFactory.instance) {
      DomainWorkerFactory.instance = new DomainWorkerFactory();
    }
    return DomainWorkerFactory.instance;
  }

  private initializeDomainConfigs(): void {
    // Collections Domain Configuration
    this.domainConfigs.set('collections', {
      name: 'collections-worker',
      database: 'COLLECTIONS_DB',
      cacheNamespace: 'COLLECTIONS_CACHE',
      routes: ['/api/domains/collections/*'],
      dependencies: ['stripe', 'paypal'],
      environment: {
        JWT_SECRET: 'collections-jwt-secret',
        STRIPE_SECRET_KEY: 'sk_test_...',
        PAYPAL_CLIENT_ID: 'paypal-client-id',
      },
    });

    // Distributions Domain Configuration
    this.domainConfigs.set('distributions', {
      name: 'distributions-worker',
      database: 'DISTRIBUTIONS_DB',
      cacheNamespace: 'DISTRIBUTIONS_CACHE',
      routes: ['/api/domains/distributions/*'],
      dependencies: ['bank-api', 'crypto-wallet'],
      environment: {
        JWT_SECRET: 'distributions-jwt-secret',
        BANK_API_KEY: 'bank-api-key',
        CRYPTO_WALLET_SECRET: 'crypto-secret',
      },
    });

    // Free Play Domain Configuration
    this.domainConfigs.set('free-play', {
      name: 'free-play-worker',
      database: 'FREEPLAY_DB',
      cacheNamespace: 'FREEPLAY_CACHE',
      routes: ['/api/domains/free-play/*'],
      dependencies: ['bonus-engine', 'fraud-detection'],
      environment: {
        JWT_SECRET: 'freeplay-jwt-secret',
        BONUS_ENGINE_KEY: 'bonus-key',
        FRAUD_API_KEY: 'fraud-key',
      },
    });

    // Balance Domain Configuration
    this.domainConfigs.set('balance', {
      name: 'balance-worker',
      database: 'BALANCE_DB',
      cacheNamespace: 'BALANCE_CACHE',
      routes: ['/api/domains/balance/*'],
      dependencies: ['ledger', 'reconciliation'],
      environment: {
        JWT_SECRET: 'balance-jwt-secret',
        LEDGER_SECRET: 'ledger-key',
      },
    });

    // Adjustment Domain Configuration
    this.domainConfigs.set('adjustment', {
      name: 'adjustment-worker',
      database: 'ADJUSTMENT_DB',
      cacheNamespace: 'ADJUSTMENT_CACHE',
      routes: ['/api/domains/adjustment/*'],
      dependencies: ['audit-log', 'compliance'],
      environment: {
        JWT_SECRET: 'adjustment-jwt-secret',
        AUDIT_SECRET: 'audit-key',
        COMPLIANCE_API_KEY: 'compliance-key',
      },
    });
  }

  /**
   * Generate Cloudflare Worker script for a specific domain
   */
  generateDomainWorker(domain: string): string {
    const config = this.domainConfigs.get(domain);
    if (!config) {
      throw new Error(`Unknown domain: ${domain}`);
    }

    const template = this.getWorkerTemplate(domain, config);
    return template;
  }

  /**
   * Get deployment configuration for a domain
   */
  getDeploymentConfig(domain: string): WorkerDeployment {
    const config = this.domainConfigs.get(domain);
    if (!config) {
      throw new Error(`Unknown domain: ${domain}`);
    }

    return {
      name: config.name,
      script: this.generateDomainWorker(domain),
      routes: config.routes,
      environment: config.environment,
    };
  }

  /**
   * Get deployment configurations for all domains
   */
  getAllDeploymentConfigs(): WorkerDeployment[] {
    const domains = Array.from(this.domainConfigs.keys());
    return domains.map(domain => this.getDeploymentConfig(domain));
  }

  /**
   * Generate wrangler.toml configuration for domain workers
   */
  generateWranglerConfig(): string {
    const deployments = this.getAllDeploymentConfigs();

    let config = `# Crystal Clear Architecture - Domain Workers Configuration
# Generated by DomainWorkerFactory
# Deploy with: wrangler deploy

name = "crystal-clear-domains"
main = "src/cloudflare-domains/domain-router.ts"
compatibility_date = "2024-01-01"

# Global environment variables
[vars]
MONITORING_ENDPOINT = "https://monitoring.crystalclear.workers.dev"
LOG_LEVEL = "info"

# Domain-specific environment variables
`;

    // Add domain-specific configurations
    deployments.forEach(deployment => {
      config += `
# ${deployment.name.toUpperCase().replace('-', '_')} Configuration
[${deployment.name}]
script = "${deployment.name}.ts"

[${deployment.name}.vars]
`;

      Object.entries(deployment.environment).forEach(([key, value]) => {
        config += `${key} = "${value}"\n`;
      });

      config += `
[${deployment.name}.routes]
`;

      deployment.routes.forEach(route => {
        config += `pattern = "${route}"\n`;
      });
    });

    // Add database and storage bindings
    config += `

# Database Bindings (D1)
[[d1_databases]]
binding = "COLLECTIONS_DB"
database_name = "collections-db"
database_id = "collections-db-id"

[[d1_databases]]
binding = "DISTRIBUTIONS_DB"
database_name = "distributions-db"
database_id = "distributions-db-id"

[[d1_databases]]
binding = "FREEPLAY_DB"
database_name = "freeplay-db"
database_id = "freeplay-db-id"

[[d1_databases]]
binding = "BALANCE_DB"
database_name = "balance-db"
database_id = "balance-db-id"

[[d1_databases]]
binding = "ADJUSTMENT_DB"
database_name = "adjustment-db"
database_id = "adjustment-db-id"

# Cache Bindings (KV)
[[kv_namespaces]]
binding = "COLLECTIONS_CACHE"
id = "collections-cache-id"
preview_id = "collections-cache-preview-id"

[[kv_namespaces]]
binding = "DISTRIBUTIONS_CACHE"
id = "distributions-cache-id"
preview_id = "distributions-cache-preview-id"

[[kv_namespaces]]
binding = "FREEPLAY_CACHE"
id = "freeplay-cache-id"
preview_id = "freeplay-cache-preview-id"

[[kv_namespaces]]
binding = "BALANCE_CACHE"
id = "balance-cache-id"
preview_id = "balance-cache-preview-id"

[[kv_namespaces]]
binding = "ADJUSTMENT_CACHE"
id = "adjustment-cache-id"
preview_id = "adjustment-cache-preview-id"

# Durable Objects for inter-domain communication
[[durable_objects]]
class_name = "DomainEventBus"
script_name = "domain-event-bus"

[[durable_objects]]
class_name = "DomainCoordinator"
script_name = "domain-coordinator"

# Build configuration
[build]
command = "npm run build"
cwd = "."

[build.upload]
format = "service-worker"
`;

    return config;
  }

  /**
   * Generate domain router that routes requests to appropriate domain workers
   */
  generateDomainRouter(): string {
    const domains = Array.from(this.domainConfigs.keys());

    let router = `/**
 * Domain Router - Crystal Clear Architecture
 *
 * Routes requests to appropriate domain workers based on URL patterns
 */

interface Env {
  COLLECTIONS_WORKER: Fetcher;
  DISTRIBUTIONS_WORKER: Fetcher;
  FREEPLAY_WORKER: Fetcher;
  BALANCE_WORKER: Fetcher;
  ADJUSTMENT_WORKER: Fetcher;
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname;

    // Route to appropriate domain worker
`;

    domains.forEach(domain => {
      const config = this.domainConfigs.get(domain)!;
      const workerName = config.name.toUpperCase().replace('-', '_') + '_WORKER';
      const routePattern = config.routes[0];

      router += `
    // ${domain.charAt(0).toUpperCase() + domain.slice(1)} Domain
    if (path.startsWith('${routePattern.replace('*', '')}')) {
      return await env.${workerName}.fetch(request);
    }
`;
    });

    router += `

    // Default response for unmapped routes
    return new Response(JSON.stringify({
      error: 'Domain not found',
      message: 'No domain worker configured for this route',
      availableDomains: ${JSON.stringify(domains)},
      path: path
    }), {
      status: 404,
      headers: { 'Content-Type': 'application/json' }
    });
  }
};
`;

    return router;
  }

  /**
   * Generate deployment script for automated deployment
   */
  generateDeploymentScript(): string {
    const deployments = this.getAllDeploymentConfigs();

    let script = `#!/usr/bin/env bash
# Crystal Clear Architecture - Domain Workers Deployment Script
# Generated by DomainWorkerFactory

set -e

echo "🚀 Starting Crystal Clear Architecture Domain Workers Deployment..."

# Check if wrangler is installed
if ! command -v wrangler &> /dev/null; then
    echo "❌ Wrangler CLI not found. Please install: npm install -g wrangler"
    exit 1
fi

# Login to Cloudflare (if not already logged in)
echo "🔐 Checking Cloudflare authentication..."
wrangler auth login --force || echo "Already logged in"

# Deploy domain workers
`;

    deployments.forEach(deployment => {
      script += `
echo "📦 Deploying ${deployment.name}..."
cat > ${deployment.name}.ts << 'EOF'
${deployment.script}
EOF

# Deploy worker
wrangler deploy ${deployment.name}.ts --name ${deployment.name}

# Configure routes
${deployment.routes.map(route => `wrangler route add "${route}" ${deployment.name}`).join('\n')}

echo "✅ ${deployment.name} deployed successfully"
`;
    });

    script += `

# Generate and deploy domain router
echo "🔄 Deploying domain router..."
cat > domain-router.ts << 'EOF'
${this.generateDomainRouter()}
EOF

wrangler deploy domain-router.ts --name crystal-clear-domains

echo "🎉 All domain workers deployed successfully!"
echo ""
echo "📋 Deployment Summary:"
`;

    deployments.forEach(deployment => {
      script += `echo "  ✅ ${deployment.name}: ${deployment.routes.join(', ')}"\n`;
    });

    script += `
echo ""
echo "🔗 Domain Router: crystal-clear-domains"
echo "📊 Monitor at: https://crystal-clear-domains.your-domain.workers.dev"
`;

    return script;
  }

  private getWorkerTemplate(domain: string, config: DomainConfig): string {
    const domainName = domain.charAt(0).toUpperCase() + domain.slice(1).replace('-', '');
    const dbBinding = config.database;
    const cacheBinding = config.cacheNamespace;

    return `/**
 * ${domainName} Domain Cloudflare Worker
 * Crystal Clear Architecture Integration
 *
 * Handles ${domain} operations using domain-driven design principles
 */

interface Env {
  ${dbBinding}: D1Database;
  ${cacheBinding}: KVNamespace;
  MONITORING_ENDPOINT?: string;
  JWT_SECRET: string;
  ${Object.keys(config.environment)
    .filter(key => key !== 'JWT_SECRET')
    .map(key => `${key}?: string;`)
    .join('\n  ')}
}

interface ExecutionContext {
  waitUntil(promise: Promise<any>): void;
  passThroughOnException(): void;
}

interface ${domainName}Data {
  id?: string;
  [key: string]: any;
}

interface DomainEvent {
  id: string;
  type: string;
  domain: string;
  data: any;
  timestamp: string;
  correlationId: string;
}

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    const url = new URL(request.url);
    const method = request.method;
    const path = url.pathname.replace('/api/domains/${domain}', '');

    try {
      // Health check endpoint
      if (path === '/health' && method === 'GET') {
        return await this.handleHealthCheck(env);
      }

      // Metrics endpoint
      if (path === '/metrics' && method === 'GET') {
        return await this.handleMetrics(env);
      }

      // Domain-specific operations
      switch (method) {
        case 'GET':
          return await this.handleGet(request, env, path);
        case 'POST':
          return await this.handleCreate(request, env, path);
        case 'PUT':
          return await this.handleUpdate(request, env, path);
        case 'DELETE':
          return await this.handleDelete(request, env, path);
        default:
          return new Response('Method not allowed', { status: 405 });
      }

    } catch (error) {
      console.error('[${domain.toUpperCase()}] Error:', error);

      // Emit error event
      await this.emitDomainEvent(env, {
        id: crypto.randomUUID(),
        type: '${domainName.toUpperCase()}_ERROR',
        domain: '${domain}',
        data: {
          error: error instanceof Error ? error.message : 'Unknown error',
          path,
          method
        },
        timestamp: new Date().toISOString(),
        correlationId: crypto.randomUUID()
      });

      return new Response(JSON.stringify({
        error: 'Internal server error',
        domain: '${domain}',
        timestamp: new Date().toISOString()
      }), {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  },

  async handleHealthCheck(env: Env): Promise<Response> {
    const health = {
      domain: '${domain}',
      status: 'healthy',
      timestamp: new Date().toISOString(),
      database: await this.checkDatabaseHealth(env),
      cache: await this.checkCacheHealth(env),
      version: '1.0.0'
    };

    return new Response(JSON.stringify(health), {
      headers: { 'Content-Type': 'application/json' }
    });
  },

  async handleMetrics(env: Env): Promise<Response> {
    try {
      const metrics = await this.getDomainMetrics(env);

      return new Response(JSON.stringify({
        domain: '${domain}',
        metrics,
        timestamp: new Date().toISOString()
      }), {
        headers: { 'Content-Type': 'application/json' }
      });
    } catch (error) {
      return new Response(JSON.stringify({
        error: 'Failed to fetch metrics',
        domain: '${domain}'
      }), {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  },

  async handleGet(request: Request, env: Env, path: string): Promise<Response> {
    // Domain-specific GET logic here
    return new Response(JSON.stringify({
      message: '${domainName} GET endpoint',
      path,
      domain: '${domain}'
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
  },

  async handleCreate(request: Request, env: Env, path: string): Promise<Response> {
    // Domain-specific CREATE logic here
    const data = await request.json();

    await this.emitDomainEvent(env, {
      id: crypto.randomUUID(),
      type: '${domainName.toUpperCase()}_CREATED',
      domain: '${domain}',
      data,
      timestamp: new Date().toISOString(),
      correlationId: crypto.randomUUID()
    });

    return new Response(JSON.stringify({
      success: true,
      message: '${domainName} created',
      domain: '${domain}'
    }), {
      status: 201,
      headers: { 'Content-Type': 'application/json' }
    });
  },

  async handleUpdate(request: Request, env: Env, path: string): Promise<Response> {
    // Domain-specific UPDATE logic here
    return new Response(JSON.stringify({
      message: '${domainName} UPDATE endpoint',
      domain: '${domain}'
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
  },

  async handleDelete(request: Request, env: Env, path: string): Promise<Response> {
    // Domain-specific DELETE logic here
    return new Response(JSON.stringify({
      message: '${domainName} DELETE endpoint',
      domain: '${domain}'
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
  },

  async getDomainMetrics(env: Env): Promise<any> {
    // Domain-specific metrics calculation
    return {
      totalRecords: 0,
      activeRecords: 0,
      successRate: 100,
      averageProcessingTime: 0
    };
  },

  async checkDatabaseHealth(env: Env): Promise<{ status: string; message: string }> {
    try {
      await env.${dbBinding}.prepare('SELECT 1').first();
      return { status: 'ok', message: 'Database connection healthy' };
    } catch (error) {
      return { status: 'error', message: 'Database connection failed' };
    }
  },

  async checkCacheHealth(env: Env): Promise<{ status: string; message: string }> {
    try {
      await env.${cacheBinding}.put('health-check', 'ok', { expirationTtl: 60 });
      const value = await env.${cacheBinding}.get('health-check');
      return value === 'ok'
        ? { status: 'ok', message: 'Cache connection healthy' }
        : { status: 'error', message: 'Cache read/write failed' };
    } catch (error) {
      return { status: 'error', message: 'Cache connection failed' };
    }
  },

  async emitDomainEvent(env: Env, event: DomainEvent): Promise<void> {
    try {
      // Store event in database for audit trail
      await env.${dbBinding}.prepare(\`
        INSERT INTO domain_events (id, type, domain, data, timestamp, correlationId)
        VALUES (?, ?, ?, ?, ?, ?)
      \`).bind(
        event.id,
        event.type,
        event.domain,
        JSON.stringify(event.data),
        event.timestamp,
        event.correlationId
      ).run();

      // Send to monitoring system if configured
      if (env.MONITORING_ENDPOINT) {
        await fetch(env.MONITORING_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            type: 'domain_event',
            event
          })
        });
      }
    } catch (error) {
      console.error('Failed to emit domain event:', error);
    }
  }
};
`;
  }
}
